#' Semi-general \code{unite} to vectorize a function across columns of dataframe
#'
#' Accepts columns from a dataframe and vectorizes/parallel maps a function
#' across them, returning the result in a new column. Function must return a
#' character vector because \code{purrr::pmap_char} enforces type-safety.
#'
#' @param df A dataframe
#' @param col Bare/unquoted name of results column
#' @param ... Bare/unquoted names of argument columns
#' @param fun A function that accepts as many arguments as provided argument
#' columns. Gets passed to \code{purrr::pmap_chr} so formula-style lambda
#' specification also works.
#' @param remove Whether or not to remove the argument columns (defaults
#' to \code{true})
#'
#' @return Dataframe with new column generated by applying \code{fun} to
#' argument columns element-wise
#' @export
#'
combine <- function(df, col, ..., fun, remove = TRUE) {
  to_merge <- quos(...)
  new_col <- quo_name(enquo(col))
  merge_cols <- map_chr(to_merge, quo_name)

  df <- mutate(df, !!new_col := pmap_chr(list(!!!to_merge), fun))
  if (remove) df <- select(df, -one_of(merge_cols))
  df
}


#' Summarize by group with less boilerplate
#'
#' @param df data frame
#' @param group_var bare/unquoted column name to group by
#' @param ... expressions as you would normally use in summarize
#'
#' @return ungrouped data frame containing results of grouped summary
#' @export
#'
summarize_by <- function(df, group_var, ...) {
  df <- dplyr::group_by(df, !!enquo(group_var))
  dplyr::summarize(df, !!!quos(...))
}


#' Mutate by group with less boilerplate
#'
#' @param df data frame
#' @param group_var bare/unquoted column name to group by
#' @param ... expressions as you would normally use in mutate
#'
#' @return ungrouped data frame containing results of grouped summary
#' @export
#'
mutate_by <- function(df, group_var, ...) {
  df <- dplyr::group_by(df, !!enquo(group_var))
  df <- dplyr::mutate(df, !!!quos(...))
  ungroup(df)
}


#' Select rows in the top n groups according to some summarization operation
#'
#' @param df data frame
#' @param group_var grouping variable
#' @param val_var value assessment variable to be summarized by group
#' @param val_fun value assessment function to apply to \code{val_var} by group
#'
#' @return data frame only with observations from top groups
#' @export
#'
top_n_groups <- function(df, group_var, val_var, val_fun = sum) {
  group_quo <- enquo(group_var)
  df2 <- dplyr::group_by(df, !!group_quo)
  df2 <- dplyr::summarize(df2, group_total = val_fun(!!val_var))
  df2 <- dplyr::top_n(df2, num_groups, group_total)
  inner_join(df, df2, !!group_quo)
}


#' Select random groups from a dataframe with NSE
#'
#' Groups a dataframe by the specified feature, selects n of these groups and
#' discards the rest. Returned dataframe is ungrouped.
#'
#' @param df A data frame or data frame like object recognized by \code{dplyr}
#' @param group_var Feature to group by. Uses NSE like dplyr verbs.
#' @param n Number of groups to take. If there are fewer than \code{n} groups, uses the
#'
#' @return Dataframe with n random groups selected according to specified grouping feature.
#' @export
#' @importFrom dplyr distinct filter
#' @importFrom magrittr "%>%"
#'
#' @examples
#' rand_n_groups(mtcars, cyl, 2)
#'
rand_n_groups <- function(df, group_var, n) {
  group_quo <- rlang::enquo(group_var)
  groups <- pull(distinct(df, !!group_quo))

  if (n > length(groups)) {
    message("N greater than number of groups, returning original dataframe.")
    return(df)
  }
  filter(df, (!!group_quo) %in% sample(groups, n))
}


#' Spread, but keeps the key column
#'
#' @param df data frame
#' @param key bare/unquoted key as in \code{spread}
#' @param value bare/unquoted value as in \code{spread}
#' @param ... additional arguments to \code{spread}
#'
#' @return spread data frame with key column retained
#' @export
#'
spread_keep <- function(df, key, value, ...) {
  key_quo <- enquo(key)
  df$.dummy <- dplyr::pull(df, !!key_quo)
  df <- tidyr::spread_(df, quo_name(key_quo), quo_name(enquo(value)), ...)
  dplyr::rename(df, !!quo_name(key_quo) := .dummy)
}

#' Spread, but keeps the key column and uses standard evaluation
#'
#' @param df data frame
#' @param key key as in \code{spread}, string
#' @param value value as in \code{spread}, string
#' @param ... additional arguments to \code{spread}
#'
#' @return spread data frame with key column retained
#' @export
#'
spread_keep_ <- function(df, key, value, ...) {
  df$.dummy <- pull(df, key)
  df <- tidyr::spread_(df, key, quo, ...)
  dplyr::rename(df, !!key := .dummy)
}

#' Repeatedly spread on a single key column
#'
#' dplyr spread generalization to spread multiple columns from the same key
#' uses select semantics for convenience, and gives the produced columns
#' informative names using the add_detail function
#'
#' @param df data frame
#' @param key bare/unquoted key column as in \code{spread}
#' @param ... tidyselect specification of columns to spread on
#' @param fill as in \code{spread}
#' @param convert as in \code{spread}
#' @param drop as in \code{spread}
#' @param sep as in \code{spread}
#'
#' @return data frame repeatedly spread on key column
#' @export
#'
spread_repeated <- function(df, key, ..., fill = NA, convert = FALSE,
                       drop = TRUE, sep = NULL) {
  for (var_name in select_vars(tbl_vars(df), !!!quos(...))) {
    df <- spread_keep_(df, key, var_name, fill, convert, drop, sep)
  }
  df
}
